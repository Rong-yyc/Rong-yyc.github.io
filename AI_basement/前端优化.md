# 计算图

## 计算图基本构成

目前主流的 AI 框架，在后端会将前端编程语言（例如 Python）构建的网络模型前向与反向的梯度计算以计算图的形式来表示。

计算图是一个有向无环图（Directed Acyclic Graph，DAG），主要用来表示神经网络模型在训练与推理过程中的计算逻辑与状态，它由基本数据结构张量(Tensor) 和基本运算单元算子(Operator) 构成。

在计算图中，常用节点来表示算子，节点间的有向线段来表示张量状态，同时也描述了计算间的依赖关系。

假设 C={N,E,I,O} 为一个计算的计算表达，那么可以有：

- 计算图表示为由一个节点 N（Node），边集（Edge），输入边（Input），输出边（Output）组成的四元组
- 计算图是一个有向联通无环图，其中的节点也被称为算子(Operator)
- 算子必定有边相连，输入边，输出边不为空
- 计算图中可以有重边（两个算子之间可以由两条边相连）

# 算子融合

融合算子出现主要解决模型训练过程中的读入数据量，同时，减少中间结果的写回操作，降低访存操作。它主要想解决我们遇到的内存墙和并行墙问题

- **内存墙**：主要是访存瓶颈引起。算子融合主要通过对计算图上存在数据依赖的“生产者-消费者”算子进行融合，从而提升中间 Tensor 数据的访存局部性，以此来解决内存墙问题。这种融合技术也统称为“Buffer 融合”。在很长一段时间，Buffer 融合一直是算子融合的主流技术。早期的 AI 框架，主要通过手工方式实现固定 Pattern 的 Buffer 融合。
- **并行墙**：主要是由于芯片多核增加与单算子多核并行度不匹配引起。可以将计算图中的算子节点进行并行编排，从而提升整体计算并行度。特别是对于网络中存在可并行的分支节点，这种方式可以获得较好的并行加速效果。

# 布局转换

​		行优先 → 列优先

​		NCHW → NHWC

# 内存分配

静态内存：模型参数等

动态内存：占据大部分NPU内存

## 串行逻辑的内存优化算法

1、空间换内存：将 GPU 或 NPU 内存中的部分模块卸载到 CPU 内存中（CPU Offload）

2、计算换内存：梯度检查点计数（Gradient Checkpointing）

3、模型压缩：量化训练、模型剪枝、模型蒸馏等

4、内存复用：替换操作、内存共享

## 并行逻辑的内存分配算法

# 常量折叠

常量折叠（Constant Folding）是编译器的一种优化技术，它通过在编译期间对常量表达式进行计算，将其结果替换为常量值，从而减少程序运行时的计算和开销。

## 传统编译器的常量折叠

传统编译器在编译期间，编译器会设法识别出常量表达式，对其进行求值，然后用求值的结果来替换表达式，从而使得运行时更精简。需要常量传播的帮助，在传统编译器中，常量传播主要是通过对控制流图(CFG)进行可达性分析

## AI编译器的常量折叠

AI 编译器是对计算图进行常量折叠优化。AI 编译器会对计算图中的每个操作节点进行分析，判断其是否可进行常量折叠。如果可以，则通过计算得到结果替换该节点。

以下是 AI 编译器常量折叠的几个类型：

- 当计算图中某个节点的数据输入节点均为编译期常量(不同 AI 编译器的定义可能完全不相同)的节点，则可以提前计算出该节点的值来完全替换该节点。
- 输入形状确定的 Shape 类型的操作
- 数据输入节点不全为编译常量节点，但是这部分节点是可常量折叠的节点，即经过一系列的常量折叠后，该节点会被替换成编译常量节点。

# 公共表达式消除

公共子表达式消除（Common Subexpression Elimination，CSE）也成为冗余表达式消除，是普遍应用于各种编译器的经典优化技术。旨在消除程序中重复计算的公共表达式，从而减少计算量和提高执行效率。

## 传统编译器的公共子表达式消除

在程序中，有时会出现多个地方使用相同的表达式进行计算，并且这些表达式的计算结果相同。重复计算这些表达式，会增加不必要的计算开销。公共表达式消除的目标就是识别出这些重复的计算，并将其提取出来，只计算一次，然后将结果保存起来供后续使用。

两种常见的公共子表达式消除方法，分别是局部值编号(LVN)和缓式代码移动(LCM)。

局部值编号(Local Value Numbering, LVN)是一种局部公共子表达式优化算法，缓式代码移动(Lazy Code Motion, LCM)使用一种数据流分析技术，通过可用表达式，可预测表达式以及延迟分析这三种数据流问题的方程，实现全局的公共子表达式消除。

## AI编译器的公共表达式消除

AI 编译器中子表达式是基于计算图或图层 IR。通过在计算图中搜索相同结构的子图，简化计算图的结构，从而减少计算开销。

# 死代码消除

死代码消除（Dead Code Elimination）是一种编译器优化技术，旨在删除程序中不会被执行的代码，从而提高程序的执行效率和资源利用率。死代码是指在程序的当前执行路径下不会被访问或执行的代码片段。

## 传统编译器的死代码消除

死代码消除的目的是删除程序中无用和不可达操作对应的代码。在传统编译器中，死代码消除通常是通过分析控制流图(CFG)，从而找到并删除无用和不可达操作对应的代码。

不可达操作：第一种是不可达基本块中的操作；第二种是由条件分支优化导致的舍弃基本块中的操作。

无用操作：无用操作是指其结果没有外部可见效应，比如冗余的变量赋值操作，该变量在定义后没有在后续的操作中使用到，不会对后续操作产生任何影响，所以可以直接删除该变量赋值操作。

需要了解后支配性和控制依赖性

## AI编译器中的死代码消除

AI 编译器通常是通过分析计算图，找到无用的计算节点或不可达的计算节点，然后消除这些节点。

# 代数简化

代数简化（Algebraic Reduced）是一种从数学上来指导我们优化计算图的方法。

代数化简可以通过子图替换的方式完成，具体实现：1）可以先抽象出一套通用的子图替换框架，再对各规则实例化。2）可以针对每一个具体的规则实现专门的优化逻辑。

## 算数简化

算术化简就是通过利用代数之间算术运算法则，在计算图中可以确定优化的运算符执行顺序，从而用新的运算符替换原有复杂的运算符组合

如：结合律、交换律、分配律

## 运行简化

运算简化，是**减少**运算或执行时，**冗余**的算子或者算子对

如：逆函数等于其自身函数的对合算子化简、幂等算子化简

## 广播简化

当多个张量形状 Shape 不同情况下，需要进行广播（broadcast）将张量的形状拓展为相同 shape 再进行运算，化简为最小计算所需的广播运算数量。