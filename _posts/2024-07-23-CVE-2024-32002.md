---
layout: post
title:  "CVE-2024-32002"
date:   2024-07-23
categories: vul_repro
---

# Git 远程代码执行

# 漏洞环境

- windows10 系统
- Git-2.45.0 / 2.44.0 / 2.43.0-2.43.4 / 2.42.0-2.42.2 / 2.41.0 / 2.40.0-2.40.2 / <2.39.4
- git 开启符号链接支持

# 漏洞复现步骤

1、在Win10安装Git-2.39.1

2、配置好 SSH key 以后，打开 git 的符号链接支持`git config --global core.symlinks true `

3、克隆恶意仓库，仓库中命令会被执行`git clone --recursive git@github.com:amalmurali47/git_rce.git`

# 漏洞原理

## git clone 

​		首先，在我们每次运行命令 `git clone` 时，实际上会进行以下操作：

```
mkdir -p <path> && cd <path>    # 创建一个与仓库同名的文件夹并进入
git init					 	# 初始化当前的 git 仓库，包括 .git 目录以及所有子目录和文件
git remote add origin <远程仓库的url> 	# 将本地仓库链接到远程仓库
git fetch origin				# 下载对象引用
git checkout -b <branch> --track origin/<branch>	# 创建本地分支，并跟踪远程分支
```

## git submodule

​		`git submodule`用于在一个 Git 仓库中嵌入另一个 Git 仓库。子模块通常用于管理大型项目中的独立依赖项或组件，这些组件可以是独立开发的代码库。

​		要将一个外部仓库作为子仓库添加到现有的 Git 中，需要如下命令:

```
git submodule add <repository_url> <path>
<repository_url>: 外部仓库的路径，例子：https://github.com/example/repo.git
<path> ： 外部仓库存放在本仓库的目录名称
```

注意：当添加子模块后，该子模块的内容会被添加到本仓库中，`.git`虽然也会出现，但它是一个**符号链接，指向本仓库 `.git/modules/<path>`**

​		当我们克隆某个具有子仓库的仓库时，用 `git clone ` 不会自动获取子仓库的内容，要想同时克隆子仓库内容，需要运行 `git clone --recursive` 命令即加上 `--recursive` 参数

## git hooks

​		Git 的 hooks 功能，详情见*[ Git官方文档 ](https://git-scm.com/docs/githooks)*。`hooks`目录存在于 `.git` 目录下，里面存放了很多 shell 脚本，这些脚本会在git执行到某个阶段时被执行。Git 的 hooks 机制主要是针对顶层仓库的 `.git/hooks` 目录中的脚本。如果你有子模块（submodule），每个子模块也会有自己的 `.git` 目录，其中包含 `hooks` 目录。对于子模块中的 hook 脚本，Git会查找并运行每个子模块自身的脚本

​		举个例子，`hooks` 目录中有个脚本名字叫做 `commit-msg`，这个脚本在执行 `git commit -m xxx` 后，消息被提交前，会被执行。

​		根据 Git 官方文档提供的说明，`post-checkout` 在执行 `git-checkout` 或 `git-switch` 命令且工作树[^1]更新后会被执行。<font color="honydew">它也会在 `git clone` 之后运行，除非使用了 `--no-checkout(-n)` 选项。</font>

## `.git` 文件夹

​		`.git` 文件夹是 Git 版本控制系统在每个 Git 仓库中创建的一个隐藏文件夹，它包含了关于该仓库的所有版本控制信息。这个文件夹对于 Git 的正常运行至关重要，它存储了仓库元数据、对象数据库，管理分支和引用，支持钩子脚本以及存储索引信息。

​		在正常情况下，新建本地仓库并 `git init` 后，会自动创建一个 `.git` 文件夹。当上传仓库到托管平台时，不会将本地的 `.git` 文件夹一起上传，仓库会自动帮助创建 `.git` 文件夹其用户无法查看和修改。故 `.git` 文件夹中的钩子脚本只会存在本地，对本地仓库起到作用。

## 攻击原理

​		然后利用了windows文件系统大小写不区分的特点，在恶意仓库中有两个文件夹分别为`A`与`a`，且`a`文件夹为符号链接，链接到了 `.git`文件夹中，而`A`是一个子模块，在其中有一个`modules`文件夹，文件夹链接到另一个保存恶意脚本的仓库，该子仓库中含有恶意脚本`y/hooks/post-checkout`。

​		在执行命令 `git clone --recursive git@github.com:amalmurali47/git_rce.git ` 时，会向保存恶意脚本的子仓库发起 `clone` 请求，并将 `post-checkout` 恶意脚本保存到目录 `A/modules/x/y/hooks/` 下。而在大小写不敏感的操作系统上，会将其保存到目录 `a/modules/x/y/hooks/` 下，而 `a` 文件夹又链接到了 `.git` 文件夹。因此实际保存恶意脚本的目录是 `.git/modules/x/y/hooks/` 目录下。

​		实际上 Git 在进行对应操作时，会先判断是否有相应的钩子脚本存在，即 `git clone` 之前，先 `hook_exists(script_name)`，若有则 `find_hook(repo, script_name)` 找到脚本文件。

<font color="red">**注：**</font>这里还不清楚 Git 的寻找子模块的钩子脚本的逻辑是什么，但是通过该漏洞猜测，直接找了 `主仓库/.git/modules/*/hooks` 中的脚本，如果查找的是 `主仓库/.git/modules/*/.git/hooks` ，可以模拟主仓库，继续使用同名文件夹和符号链接的方法将钩子脚本放入子仓库的 `.git`文件夹中去

# 防御措施

1、升级 git 版本

2、禁用 git 的符号链接功能

3、不要克隆来路不明的恶意仓库

[^1]: Git 的工作树（Working Tree），也被称为工作目录（Working Directory），工作树是仓库中实际包含项目文件的目录，是你日常工作的地方，你可以在这个目录下创建、编辑、删除文件，就像在普通文件夹中操作一样。